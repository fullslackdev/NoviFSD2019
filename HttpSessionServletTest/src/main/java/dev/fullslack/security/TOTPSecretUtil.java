package dev.fullslack.security;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.security.auth.Destroyable;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.*;

public class TOTPSecretUtil {
    private static final Logger LOGGER = LogManager.getLogger(TOTPSecretUtil.class.getName());

    private static final int AUTH_TAG_SIZE = 128; // bits

    private static final int IV_LEN = 12; // bytes

    // number of random number bytes generated before re-seeding
    private static final double PRNG_RESEED_INTERVAL = Math.pow(2, 16);

    private static final String ENCRYPT_ALGO = "AES/GCM/NoPadding";

    private static final List<Integer> ALLOWED_KEY_SIZES = Arrays.asList(
            new Integer[] {128, 192, 256}); // bits

    private static final String ALGORITHM = "AES";

    private static SecureRandom prng;

    // Used to keep track of random number bytes generated by PRNG
    // (for the purpose of re-seeding)
    private static int bytesGenerated = 0;

    public String encrypt(String input, String keyInput) {
        Objects.requireNonNull(input, "Input message cannot be null");
        Objects.requireNonNull(keyInput, "Key cannot be null");

        if (input.length() == 0) {
            throw new IllegalArgumentException("Length of message cannot be 0");
        }

        SecretKeySpec key = decodeSecretKeySpecString(keyInput);

        if (!ALLOWED_KEY_SIZES.contains(key.getEncoded().length * 8)) {
            throw new IllegalArgumentException("Size of key must be 128, 192 or 256");
        }

        byte[] inputBytes = input.getBytes(StandardCharsets.UTF_8);

        Cipher cipher;
        byte[] iv = null;
        GCMParameterSpec gcmParamSpec;
        byte[] messageCipher = null;

        try {
            cipher = Cipher.getInstance(ENCRYPT_ALGO);
            iv = getIV(IV_LEN);
            gcmParamSpec = new GCMParameterSpec(AUTH_TAG_SIZE, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key, gcmParamSpec);
            messageCipher = cipher.doFinal(inputBytes);
        } catch (Exception ex) {
            LOGGER.error("Error Message Logged !!!",ex.getMessage(),ex);
        }

        // Prepend the IV with the message cipher
        byte[] cipherText = new byte[messageCipher.length + IV_LEN];
        System.arraycopy(iv, 0, cipherText, 0, IV_LEN);
        System.arraycopy(messageCipher, 0, cipherText, IV_LEN, messageCipher.length);
        return Base64.getEncoder().encodeToString(cipherText);
    }

    public String decrypt(String input, String keyInput) {
        Objects.requireNonNull(input, "Input message cannot be null");
        Objects.requireNonNull(keyInput, "Key cannot be null");

        if (input.length() == 0) {
            throw new IllegalArgumentException("Length of message cannot be 0");
        }

        SecretKeySpec key = decodeSecretKeySpecString(keyInput);

        byte[] inputBytes = Base64.getDecoder().decode(input);

        byte[] iv = new byte[IV_LEN];
        System.arraycopy(inputBytes, 0, iv, 0, IV_LEN);

        byte[] messageCipher = new byte[inputBytes.length - IV_LEN];
        System.arraycopy(inputBytes, IV_LEN, messageCipher, 0, inputBytes.length - IV_LEN);

        GCMParameterSpec gcmParamSpec = new GCMParameterSpec(AUTH_TAG_SIZE, iv);

        Cipher cipher;
        String output = "";

        try {
            cipher = Cipher.getInstance(ENCRYPT_ALGO);
            cipher.init(Cipher.DECRYPT_MODE, key, gcmParamSpec);
            output = new String(cipher.doFinal(messageCipher), StandardCharsets.UTF_8);
        } catch (Exception ex) {
            LOGGER.error("Error Message Logged !!!",ex.getMessage(),ex);
        }

        return output;
    }

    private byte[] getIV(int bytesNum) {
        if (bytesNum < 1) {
            throw new IllegalArgumentException("Number of bytes must be greater than 0");
        }

        byte[] iv = new byte[bytesNum];

        prng = Optional.ofNullable(prng).orElseGet(() -> {
            try {
                prng = SecureRandom.getInstanceStrong();
            } catch (NoSuchAlgorithmException ex) {
                throw new RuntimeException("Wrong algorithm name", ex);
            }
            return prng;
        });

        if ((bytesGenerated > PRNG_RESEED_INTERVAL) || (bytesGenerated == 0)) {
            prng.setSeed(prng.generateSeed(bytesNum));
            bytesGenerated = 0;
        }

        prng.nextBytes(iv);
        bytesGenerated = bytesGenerated + bytesNum;

        return iv;
    }

    private static void clearSecret(Destroyable key) throws Exception {
        Field keyField = key.getClass().getDeclaredField("key");
        keyField.setAccessible(true);
        byte[] encodedKey = (byte[]) keyField.get(key);
        Arrays.fill(encodedKey, Byte.MIN_VALUE);
    }

    public String createSecretKeySpec() {
        return createSecretKeySpec(256);
    }

    public String createSecretKeySpec(int keySize) {
        KeyGenerator keyGen = null;
        try {
            keyGen = KeyGenerator.getInstance(ALGORITHM);
            keyGen.init(keySize, SecureRandom.getInstanceStrong());
        } catch (NoSuchAlgorithmException ex) {
            LOGGER.error("Error Message Logged !!!",ex.getMessage(),ex);
        }

        SecretKey secretKey = keyGen.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), ALGORITHM);
        return Base64.getEncoder().encodeToString(secretKeySpec.getEncoded());
    }

    private SecretKeySpec decodeSecretKeySpecString(String input) {
        SecretKeySpec secretKeySpec = new SecretKeySpec(Base64.getDecoder().decode(input), ALGORITHM);
        return secretKeySpec;
    }
}
